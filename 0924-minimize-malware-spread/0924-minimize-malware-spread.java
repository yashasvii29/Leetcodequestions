class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        DSU ds = new DSU();
        for(int i=0;i<graph.length;i++){
            ds.create(i);
        }
        for(int i=0;i<graph.length;i++){
            for(int j=i+1;j<graph.length;j++){
                if(graph[i][j]==1){
                    ds.union(i,j);
                }
            }
        }
        int count[]=new int[graph.length];
        for(int node:initial){
            count[ds.find(node)]++;
        }

        int ans = -1;
        int anssize = -1;
        for(int i=0;i<initial.length;i++){
            int node = ds.find(initial[i]);
            if(count[node] == 1){
                int cursize = ds.size(node);
                if(cursize>anssize){
                    ans=initial[i];
                    anssize=cursize;
                }
                else if(cursize==anssize){
                    ans=Math.min(ans,initial[i]);
                    anssize=cursize;
                }
            }
        }
        if(ans == -1){
            ans = Integer.MAX_VALUE;
            for(int i=0;i<initial.length;i++){
                ans=Math.min(initial[i],ans);
            }
            return ans;
        }
        return ans;
    }
    public class DSU {
    class Node {
        int vtx;
        Node parent;
        int rank;
    }
     HashMap<Integer,Node> map=new HashMap<>();
    // map m vertex ke corressponding parent ka address rakhenge 
    public void create(int v){
        // create method ki tc O(1) in dsu 
        //bcz  map m element add kr rhe hai in constant time
        // set create krenge
        Node nn=new Node();
        nn.vtx=v;
        nn.parent=nn;
        nn.rank=1;
        map.put(v,nn);
        // Hashmap m vertex ke corressponding uss node ka address means set ka address rakhenge
    }
    public int find(int v){
        //  find() ki tc O(logn) bcz tree ki jitni height hai vahan tak find krenge and always remember height ke term m tree ki tc O(logn) hoti h
        // iss function se vertex ka representative no. find krenge
        Node nn=map.get(v);
        return find(nn).vtx; // yahan se private wala find fun call hoga aur usme uss vertex ka address bhejenge jiska ren find krna hai
    }
    private Node find(Node nn){
        // y function vertex ke representative no. ka address return krega
        if (nn.parent==nn){
            return nn;
        }
        Node ren= find(nn.parent);
        nn.parent=ren;//path compression isse code ki time complexity kam ho jayegi...means 7 vertex ke parent m direct ren ka address assign kr denge iss code ki tc kam ho jayegi
        return ren;
}    
    public void union(int v1,int v2){
        Node n1=map.get(v1);
        Node n2=map.get(v2);
        Node ren1=find(n1);
        Node ren2=find(n2);
        // ren1.parent = ren2;
        // ren2.rank=ren1.rank+ren2.rank;
          if (ren1 != ren2) {
            if (ren1.rank > ren2.rank) {
                ren2.parent = ren1;
                ren1.rank += ren2.rank;
            } else {
                ren1.parent = ren2;
                ren2.rank += ren1.rank;
            }
        }
    }
    public int size(int v){
        Node nn = map.get(v);
        return find(nn).rank;
    }
}
}