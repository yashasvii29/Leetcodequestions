class Solution {
    public int nthSuperUglyNumber(int n, int[] primes) {


//         \U0001f501 Super Ugly Number vs Ugly Number:
// Type	Description
// Ugly Number	Prime factors only from [2, 3, 5]
// Super Ugly Number	Prime factors only from a custom list like [2, 7, 13, 19]

// \U0001f4cc Key Points:
// Always starts with 1.

// Generated by multiplying previous super ugly numbers with the primes from the list.

// The list of super ugly numbers is built in ascending order.

// You can think of it as a generalized version of the classic ugly number problem.


// Then the super ugly numbers in order (starting from 1) are:

// scss
// Copy
// Edit
// 1,
// 2  (1 × 2),
// 4  (2 × 2),
// 7  (1 × 7),
// 8  (4 × 2),
// 13 (1 × 13),
// 14 (2 × 7),
// 16 (8 × 2),
// 19 (1 × 19),
// 26 (2 × 13),
// 28 (4 × 7),
// 32 (16 × 2)
// So the 12th super ugly number is 32.


 int k = primes.length;
        long[] dp = new long[n];  // dp[i] stores the i-th super ugly number          // Use long
        int[] indices = new int[k];    // pointers for each prime
        long[] values = new long[k];   // current prime multiples     // Use long

        dp[0] = 1;    // First super ugly number is always 1


          // Initialize values with primes (1 * prime)
        for (int i = 0; i < k; i++) {
            values[i] = primes[i];
        }

        for (int i = 1; i < n; i++) {

             // Get the minimum among all current prime multiples
            long min = Long.MAX_VALUE;

            for (long val : values) {
                if (val < min) {
                    min = val;
                }
            }

            dp[i] = min;


             // Update all primes that match the minimum
            for (int j = 0; j < k; j++) {
                if (values[j] == min) {
                    indices[j]++;
                    values[j] = dp[indices[j]] * primes[j];
                }
            }
        }

        return (int) dp[n - 1];

        
    }
}